% !TEX root = ../lc_main.tex
\section{Background and Related Work}

\subsection{Light clients and off-chain payments}
Our approach facilitates transaction submission for a light client that is not aware of the history of a blockchain.
Therefore, we compare our work with existing solutions for light clients as well as mechanisms that allow the interaction with a blockchain when in resource constrained operation.
Our approach is different from a more ``traditional'' (i.e., what commonly is referred to) light client that has the primary goal of syncing to the blockchain in order to acquire the information necessary to interact with a smart contract or to submit a transaction.
We summarize the most important concepts and works in the area of light clients below.

We first describe the common idea of a light client and then outline concepts related to our work that complement light clients.

A summary of \textbf{light client research} can be found in~\cite{soklc}, listing the main functionalities a light client is expected to perform: (1) issue queries, such as for the balance of an account, or the state of a transaction, and (2) safeguard secrecy information and submit transactions to the blockchain.
In order to implement these functionalities, light clients use several generic techniques, most notably: header verification and consensus evolution verification. Compared to a \emph{full node} a light client only verifies the headers of blocks and skips the verification of transactions and account balances, a technique made popular with SPV in Bitcoin~\cite{spv} and nearly adopted by most practical approaches for light clients, e.g.,~\cite{Ethereumlc}.
In addition to that, consensus evolution verification is needed for proof-of-stake based blockchains as the validator set can change.
Another common technique is to compress blockchain and/or ledger state to reduce the information a light client has to download to verify proofs and synchronize to the blockchain (see, e.g.,~\cite{flyclient}).
Some light clients use game-theoretic assumptions to implement the slashing of previously deposited collateral in case of misbehavior, for example~\cite{superlight}.
The main cryptographic building blocks that are used to realize those techniques are succinct representation and proofs, such as data accumulators (often Merkle trees) and commitments and SNARKs.
Furthermore, suitable signatures and hash functions are needed, for example, aggregate signatures and threshold signatures.

Most related works and ideas are \textbf{intents} and \textbf{solver networks} that attempt to establish a relationship between solvers and users via their (light) clients~\cite{ethresearch-solvers}.
A light client issues an intent via as an abstracted transaction object and solvers process the intent incentivized by transaction fee or intent execution reward. The users are then free to accept or reject a solverâ€™s proposal.
Outsourcing transaction creation to a solver does not need for user to bridge assets cross-chain, as chains are abstracted away. In case the solvers are required to provide a deposit, slashing guarantees honest behavior of a rational actor.
While concepts around solver networks are relatively new there is currently no universal standard governing the specification for intents and abstract transaction objects.
 To the best of our knowledge, this is the first work describing an intent-based light client protocol.

\textbf{Payment channels}.
We also briefly cover \textbf{payment channels} (also called \textbf{state channels}), which also constitute
a concept similar to our approach:
payment channels describe a type of off-chain mechanism for blockchains. They allow to establish a private payment
channel between two parties. The channel can be used to conduct a series of (similar) transactions without interacting
with the main blockchain. The creation of a payment channel requires locking funds in a smart contract, which is used
to conduct the transactions~\cite{payment-channel}. Some state channels, such as Hydra \cite{hydra}, not only allow
for simple payments between users, but simulate the majority of the on-chain transaction processing mechanism internally.

Participation in a payment channel usually presumes that a user is able to predict, to some degree, the nature of the
anticipated payments they will send or receive, and accepts that interactions within the channel will be limited
to users, contracts, and tokens, available in that channel (i.e. locked by the channel's smart contract).
Due to the specifics of the channel setup process, and the limited nature of these interactions, payment channels
are capable of greatly improving scalability
and reducing transaction processing times. The target user base for our light client design, however, are ones
that do not wish to engage in establishing relationships with other chain users, participating
in an on-chain setup process, or intend to make repeat or scheduled interactions with the same
users. The on-chain space- and cost-saving benefits of payment channels,
which are due to not posting every single transaction, are unlikely to be accessible to a user base which
we target with our low-commitment design. For these reasons, it does not make sense to limit themselves
to a specific payment channel.

Similarly, our design should be general enough to support any transaction or on-chain operation, irregardless of its monetary value or physical size.
One potential problem in payment channels is liquidity. If one of the parties does not have sufficient 
liquidity in the channel, payments might fail or need to be routed
 through multiple channels\footnote{Payment networks attempt to address this issue
  by using multi-path payments, where the original payment is split into smaller parts,
   each routed through different channels, allowing for greater liquidity}, adding complexity and risk.
Our construction does not suffer from those shortcommings while at the same time provinding the same level of atomicity expected from payment channels, i.e., payments are either fully successful or completely fail.

Some existing proposals\cite{todo} suggest to augment payment channels with the ability to process any off-chain interaction, not just payments. Often those constructions are called state channels. Off-chain interactions that go beyond transaction do however entail increased complexity. The base/main chain needs to offer smart contract support. Hash Time-Locked contracts (as used in the Lightning Network) are not sufficient for complex off-chain interactions.

Availability/Being online: Payment channels (and certain payment networks) require that the participants are ``always'' online and observe the main chain for updates (e.g., an updated smart contract).
A possibly remedy for this inconvenience are watchers. They make sure that channels are fair by monitoring the state of the payment channels. They check if either participant tries to broadcast an invalid transaction--- such as an old state---in order to claim more funds than they are entitled to. If a participant tries to cheat, the watcher can detect this and, trigger a penalty transaction that punishes the dishonest participant by forfeiting their funds.
Being always online is not mandatory for the user in our light client protocol. The user might observe the chain to verify if their transaction has been included and the funds have been transferred, however, not being online can never result in a scenario where a party wrongfully claims funds and active intervention on the user's part is required to prevent this.


\todobox{
some payment networks in the wild:\\
Lightning network (Bitcoin)
Raiden Network for Ethereum, which also utilizes payment channels for faster payments, or Liquid Network (a sidechain to Bitcoin)
Celer Network?
Stellar network?
RippleNet?
Celo network?
}


\textbf{API and Explorer Services}.
Many realistic UTxO ledger implementations (e.g. Ergo \footnote{\url{https://ergoplatform.org/}},
Cardano \footnote{\url{https://cardano.org/}}, and BitCoin \footnote{\url{https://bitcoin.org/}}) are set up
in a way that a badly constructed transaction will, in many cases, not result in any update to the ledger
state. So, even if a transaction is constructed by an LC based on ledger or block data that is incorrect or
old, the worst-case scenario is that it will be rejected. This makes
services such as blockchain explorers \footnote{\url{https://beta.explorer.cardano.org/}} or Blockfrost (API
as a service for accessing the Cardano blockchain) \footnote{\url{https://blockfrost.dev/}} are some of the
strongest competitors with our proposal, as they provide the data needed
for the LC to construct their transaction, often with a relatively high degree of reliability.
One aspect that sets our design apart is the SP compensation structure. Revenue from services such as those above is
either ad-based, requires users to create an account paid for with fiat currency, or is free in order to
promote use of the specific service/blockchain. We, on the other hand, propose that SPs are compensated
in assets on the same blockchain as the one to which their transaction gets applied, and the payment structure
consists of a one-time, no-setup atomic exchange of assets for services. Since the SP in our design gets paid
only once a transaction is successfully applied, all data for which they receive payment
is not just reliable (as for existing services), but provably correct.

\subsection{Hierarchical Deterministic wallets and address discovery}
UTXO based blockchains, including Bitcoin and Cardano use the concept of Hierarchical Deterministic (HD) wallets \cite{bip32} where child addresses can be created in a deterministic way using a public key of a keypair $sk,pk$, and some short auxiliary data (the chain code). Given a public key $pk$, chain code $c$ and requested index $i$ for a child key, a hash function is used to produce a scalar $s_i$ enablind the derivation of the child key as $sk_i=sk+s_i$. It is also possible to use $s_i$ without knowing $sk$ to directly derive the corresponding public key $pk_i=pk\cdot g^{s_i}$. The same method is used to produce a child chain code $c_i$, so that multiple generations of keys are possible.

In our application, we can assume that a wallet can give the SPO a single public key and chain code, letting the SPO do address derivation and lookup on their side, using some agreed-upon bounds, or heuristics on the index depth. This keeps the communication cost from the light client to the SPO constant.


\subsection{Schnorr Blind Signatures}
As soon as their patent expired in 2008, Schnorr signatures~\cite{10.1007/0-387-34805-0_22} have been gaining significant adoption,
replacing RSA in many scenarios due to their smaller size and faster verification.
Compared to (EC)DSA, Schnorr offers similar efficiency and guarantees,
but (EC)DSA security proofs are most likely not possible without 
strong idealization~\cite{cryptoeprint:2023/914}.
As a consequence, EdDSA~\cite{cryptoeprint:2011/368}, a popular variant of the
 Schnorr scheme, is currently under consideration by NIST for standardization.
The security of Schnorr signaatures is based on the discrete 
logarithm assumption~\cite{jofc-2000-14276},
with proofs in the random oracle model (ROM) as well as in 
the algebraic group model (AGM) and the ROM~\cite{10.1007/978-3-030-45724-2_3}.

Standard Schnorr signatures are now widely used in blockchains such as Bitcoin, Bitcoin Cash, Litecoin, and Polkadot.
Monero, Zcash, and Cardano use the EdDSA variant.
The adption of Schnorr and EdDSA signatures is driven by privacy~\cite{cryptoeprint:2022/1636} and
 scalability gains~\cite{10.1007/s10623-019-00608-x}
but also the straightforward extension to \emph{blind Schnorr signatures}~\cite{10.1007/3-540-48071-4_7}.
Most Schnorr-based blind signature schemes
require multiple rounds~\cite{10.1007/3-540-48071-4_7,,}, which can make the protocol suceptible to denial-of-service attacks.
Research has thus been focusing on making blind signatures \emph{concurrently} secure where more than one session can be interwined~\cite{}. % as well as round-optimal schemes~\cite{}.

Our construction hinges on the the concurrently secure blind and partially blind signing protocol
for standard Schnorr signatures found in~\cite{blindsigs} by Fuchsbauer, et al.---the first work stating rigorous security guarantees for a practical blind signature scheme based on Schnorr signatures.
Unlike schemes that had been presented before,~\cite{blindsigs} is not vulnerable to the attacks described in~\cite{10.1007/3-540-45708-9_19,cryptoeprint:2020/945} which showed that the hardness-assumption\footnote{The ROS (Random inhomogeneities in a Overdetermined
Solvable system of linear equations) problem was initially studied by Schnorr in~\cite{10.1007/3-540-45600-7_1}} existing schemes relied on for concurrent security can be solved in polynomial-time.
As our light client protocol is based on~\cite{blindsigs}, it also provides partial and predicate blindness, two properties that allow us to describe a transaction in an abstract way featuring ``redacted'' parts.
We briefly outline the construction of Fuchsbauer et al.~\cite{blindsigs} in the following.
The scheme is equivalent to the blind signature scheme~\cite{10.1007/3-540-48071-4_7} by Chaum and Pedersen but, in order to make the protocol concurrently secure, adds a commitment phase at the beginning where the user sends an encrypted version of the message $m$ and blinding values $(\alpha,\beta)$ to the signer.
In addition to that, the second message by the user includes a zero-knowledge proof alongside the Schnorr challenge $c$.
The zero-knowledge proof asserts to the signer that the initial (encrypted) commitment and $c$ have been derived from the same $m, \alpha, \beta$.

In addition to obtining concurrent security, one can leverage the zero-knowledge proof to assert additional facts, most notably, the user can prove to the signer that certain predicate(s) over message $m$ holds. This effectively turns the fully blind scheme into a predicate blind scheme.
Furthermore, support for predicate blindness implies partial blindness~\cite{blindsigs} since constructing a predicate that checks equality for parts of $m$ can be used to assert to the user that parts of the message correspond to the expected value(s).

\todobox{
Compare our approach  with :
\begin{itemize}
    \item "Free" websites monitoring the chain -- mention they lack long-term sustainability. mention big APIs. blockfrost, etc.
    \item Bridges (trustless and trusted). only overview. maybe SOK paper. and describe how LC and bridge are related.
    \item Payment channels (require upfront capital) + Payment networks~\cite{cryptoeprint:2017/823}
    \item LCs that operate on single-prover model (eg. with an established relationship via deposit)
    \item LCs that operate on multi-prover model
	%\item Time lock micro payment channel~\cite{{10.1007/978-3-319-21741-3_1}
\end{itemize}}


