% !TEX root = ../lc_main.tex

\section{Implementation}
To assess the efficiency of our construction we implement and benchmark the $\NArg$ component. Given today's implementations of zk-SNARKs, running the $\NArg$ is expected to be the most time and resource intensive part of our light client protocol.

We base our tests on the trusted-setup zk-SNARK system \emph{Groth16}~\cite{cryptoeprint:2016/260} implemented by \emph{Iden3}~\cite{circom}.
The circuits we construct and benchmark are inspired by the implementation of~\cite{blindsigs} and written in the domain-specific language of Circom~2.1.

The NArg we implement captures relation $\mathrm{R}_{\mathrm{CAVEFISH}}$ in the protocol in Section~\ref{sect:ourscheme}.
We note that the abstract transaction $\var{tx}_A$ is part of the known statement $\theta$ in $\mathrm{R}_{\mathrm{LCP}}$ as it constitutes an input to the predicate $P:= \var{int_{post}}$.


% proving: $\fun{chkSpec}(\var{int_{post}},\var{tx}) = 1$ $\land \var{Com}(\var{tx};\rho)$ from %\begin{equation}
%\label{narg}
%\mathrm{R}_{\mathrm{LCP}}
%	(\underbrace{(q, \mathbb{G}, G, \mathsf{H})}_{\text{parameters}\ par},\
%	\overbrace{(X_{\mathrm{client}}, R, com_\mathrm{tx}, \var{tx}_A, c, \var{int_{post}} )}^{\text{known statement}\ \theta}\ ,\
%	 \underbrace{(\var{tx}||\var{nt}, \rho)}_{\text{witness}\ \omega}\ )
%\end{equation}

\subsection{Design choices}
We implement and measure the arithmetic complexity of the relation in Eq.~\ref{narg} for different scenarios and for different blockchain systems.
We use BN254 as the curve for \emph{Groth16} to operate on, i.e., the curve group has 254 bits and the relation is instantiated over an arithmetic circuit with modulus of 254 bits. %, i.e., the order of the group given by  BN254 has 254 bits.
The BN254 curve is one of the standard choices in Circom and forces the inputs to the circuit to be elements of the field given by BN254. 
We capture transaction $\var{tx}$ and abstract transaction $\var{tx_A}$ as bit strings of some length $n$ encoded as field elements, which allows us to instantiate a circuit that can handle transactions of length up to $n$.

In order to implement the encryption scheme $\PKE$ that is needed to encrypt $tx$ as $C$, 
 we use ElGamal~\cite{elgamal1985public} public key encryption over the Baby-JubJub curve~\cite{whitehat2020baby}.
 The reason for choosing Baby-JubJub curve is that the field given by BN254 is the base field of the Baby-JubJub curve and thus, any element can be represented as two elements of the BN254 field. As a consequence, the group operation is efficiently arithmetizable in the circuit~\cite{blindsigs}.
 Furthermore, we encapsulate key and encrytion of ElGamal using DHIES~\cite{abdalla1999dhaes}, i.e., the shared secret in ElGamal serves as a seed to the PRF generating random group elements for an additive one-time-pad that encrypts $tx$. The PRF is instantiated as a Poseidon hash~\cite{263850} that is efficiently arithmetizable by design.

Unfortunately, most common cryptographic hash functions are not ``circuit-friendly''~\cite{263850} and thus it would be beneficial to optimize the hash function used to create the Schnorr challenge in the blind signature protocol. To be compatible with existing blockchain platforms and create standard Schnorr signatures, we have to adopt the exact hash function specified by the respective ledger. We use the library of hash functions in~\cite{komuves2025hashcircuits} which provides Circom implementations for many popular hash functions. The authors put effort into the optimization but 
more efficient implementations might be possible.
Despite potential further improvements, the complexity of our resulting circuit is mainly governed by number of rounds the hash function has to execute when producing the Schnorr signature.


\subsection{Benchmarks}

\textcolor{orange}{mr: WIP}
We test and benchmark (1) partially blind and (2) predicate blind signatures for both, Bitcoin and Cardano.
Partial blindness can be interpreted as a predicate and hence our scheme allows to combine partial blindness and other predicates.

We measure the number of contraints, proving key size and proof size.
 We also measure the time it takes to creat the resulting circuit, the proving time and the proof verification time.
 The results are summarized in Table~\ref{table_results} for different scenarios we describe in the following. The experiments were executed on commodity hardware based on an Intel(R) Core(TM) i7-8750H CPU operating at 2.20GHz with 12 cores and 16GB of RAM.


\begin{table}[h!]
\centering
\caption{Different scenarios for Bitcoin and Cardano. Predicate blindness and partial blindness.}
\label{table_results}
\begin{tabular}{@{} lcccccc @{}}
\toprule
  & \multicolumn{2}{c}{\textbf{Bitcoin}} & & & \multicolumn{2}{c}{\textbf{Cardano}} \\
\midrule
Signature scheme & \multicolumn{2}{c}{Schnorr} & & & \multicolumn{2}{c}{EdDSA} \\
Curve        & \multicolumn{2}{c}{Secp256k1} & & & \multicolumn{2}{c}{Ed25519}           \\
Hash          & \multicolumn{2}{c}{SHA-256} & & & \multicolumn{2}{c}{SHA-512}          \\
\midrule
\multirow{2}{*}{Blindness type}     & predicate & partial & & & predicate & partial \\
 & $TX.out \le t$ & xzy blinded & & & $TX.out \le t$  & 333b blinded\\
Transaction size & 256B & xzy B & & & 285B & xzy B\\
\midrule
Proving key size & 115 MB & & & & & 116 MB\\
Proving key verification time & 19.3 s & & & & & 20.5 s \\
Verification key size & 3.3 kB & & & & & 93 kB\\
Proving time & 5.2 s & & & & & 5.8 s\\
Proof size & 804 B & & & & & 805 B\\
Proof verification time & 0.6s & & & & & 0.6s\\
Number of constraints & 228k & & & & & 245k\\
\bottomrule
\end{tabular}
\end{table}

\textbf{Signing the hash.}
In Bitcoin, we note that message being signed in our relation is the hash of the transaction $\mathsf{H}(tx)$.
Thus the witness--strictly speaking--only contains the transaction $tx$, but we list $\mathsf{H}(tx)$, for completeness as the message being signed is $m \equiv \mathsf{H}(tx)$.


\textbf{Predicate blindness.}



\textbf{Partial blindness.}



%The most obvious choice is to blind/redact the UTxO references serving as the inputs to the transaction preventing a light client from constructing the transaction on its own, without the inclusion of the output that represents the tip/reimbursement to the service provider. If the light client posts the modified transaction on chain and thereby circumvents the service provider, no tip is due and the light client is able to obtain information that constitutes a valid transaction for free.

