% !TEX root = ../lc_main.tex

%\subsection{Technical Background}
%UTxO model \textcolor{orange}{mr: do we still need this subsection?}

\section{Technical Background}

\textbf{Notation} We use $y \gets x)$ to denote that  variable $y$ is assigned the (possibly randomized) evaluation of $x$. When $x$ is a set, we denote uniformly random sampling from the set. We use $a=b$ to denote boolean comparison between $a$ and $b$ and $z:=w$ to denote equality by definition. We use $||$ to denote concatenation of bitstrings. When algorithms are randomized, we denote them as $A(x;r)$, where $x$ is the input and $r$ is the randomness, belonging to a randomness space $\mathcal{R}$. When we write $y\gets A(x)$ we imply $r\gets \mathcal{R};y\gets A(x;r)$. In algorithm descriptions we write $x,y,z \subseteq a$ to imply parsing $a$ to obtain $x,y,z$. 

\subsection{Discrete Log Groups}
\begin{definition} A group generator \GGen is a probabilistic polynomial time (p.p.t.) algorithm with input a security parameter $\lambda$ and outputs a group description $\G,g,q$ such that $\G$ is a group of prime order $q\approx 2^\lambda$ with generator $g$. We say that the discrete logarithm problem is hard w.r.t. \GGen{} if for all p.p.t $\A$ we have that

$$\Pr[(\G,g,q) \gets \GGen(1^\lambda); t\gets \Z_q; h\gets g^t: t=A(\G,g,q,h) ] \mbox{ is negligible in }\lambda.$$
\end{definition}

\subsection{ Public Key encryption and Schnorr Signatures}

A public key encryption scheme $\PKE$ comprises a set of polynomial time algorithms $\Keygen,\Enc,\Dec$ with the following syntax:
\begin{itemize}
\item $\Keygen(1^\lambda) \to (ek,dk)$. Creates a public/private keypair $ek,dk$. The encryption key $ek$ also defines the message space $\mathcal{M}$
\item $\Enc(ek,m;\rho) \to C$. Encrypts a message $m\in \mathcal{M}$ under the public encryption key $ek$. \item $\Dec(dk,C) \to m$. Decrypts a ciphertext $C$ using the private decryption key $dk$.
\end{itemize}

\begin{definition} A public key encryption scheme $\PKE$ is \emph{correct} if 
$$\Pr[ (ek,dk) \gets \PKE.\Keygen(1^\lambda); m\gets \mathcal{M}:\PKE.\Dec(sk,\PKE.\Enc(pk,m))=m ] =1.$$
\end{definition}

\begin{definition} A public key encryption scheme $\PKE$ is \emph{IND-CPA secure} if for all stateful p.p.t. adversaries \A, the difference
$$\left| \Pr[ (ek,dk) \gets \PKE.\Keygen(1^\lambda); (m_0,m_1)\gets A(ek);d\gets\{0,1\}; c^*\gets \PKE.\Enc(ek,m_d):A(c^*)=d ] - {1\over2} \right|$$
is negligible in $\lambda$.
\end{definition}

The security of the Schnorr signature scheme has been well studied in the random oracle model, however in this work the need arises to instantiate the underlying hash function $\hash$ so that we may reason about it inside zero knowledge proof systems. This will render existing proofs ineffective necessitating an assumption on the security of the scheme. This does not differ significantly from typical implementation practices (where the hash function is drawn from a small pool for standardized options), and also from the treatment of this issue in the literature. +++refs  


\begin{definition} A hash function generator $\HGen(n) \to \hash$, on input $n\in \N$ generates a hash function $\hash : \{0,1\}^* \to \Z_n$.
\end{definition}


\begin{definition} The Schnorr digital signature scheme $\SDS$ is defined for a group generator $\GGen$ and a hash function generator $\HGen$ and operates as shown on Figure \ref{fig:schnorr}.\end{definition}


\begin{figure}[ht]
\fbox{%
  \begin{minipage}{0.95\textwidth}
    % Top minipage
    
    \begin{minipage}[t]{0.05\textwidth}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.4\textwidth}
    
 \textbf{\uline{\bm{$\SDS.\Setup(1^\lambda)$}}}\\[0.5ex]
$(\G,g,q) \gets \GGen(1^\lambda)\\$
$\hash\gets  \HGen(q)\\$
$sp \gets (\G,g,q,\hash)\\$
$\textbf{return } sp\\$


      \textbf{\uline{\bm{$\SDS.\Sign (sk,m)$}}}\\[0.5ex]
$(\G,g,q,\hash,x):\subseteq sk$\\
$r\gets \Z_q; R\gets g^x ; c\gets \hash(R,X,m) \\$
$s\gets (r+c\cdot x) \mod q\\$
$\textbf{return } \sigma \gets(R,s)\\$\\
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.40\textwidth}
      \textbf{\uline{\bm{$\SDS.\Keygen (sp)$}}}\\[0.5ex]
$(\G,g,q) :\subseteq sp\\$
$x\gets \Z_q; X\gets g^x \\$
$sk,vk \gets (par,x),(par,X)\\$
$\textbf{return } (sk,vk)\\$\\


%\vspace{.5cm}
       \textbf{\uline{\bm{$\SDS.\Ver(vk,m,\sigma)$}}}\\[0.5ex]
$(\G,g,q,\hash,X):\subseteq vk$\\
$(R,s)\gets \sigma; c\gets \hash(R,X,m)$\\
$\textbf{return } (g^s=R\cdot X^c)$

    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.1\textwidth}
    \end{minipage}

  \end{minipage}%
}

\caption{The  Schnorr signature scheme \SDS, with group and hash generators \GGen,   \HGen.}\label{fig:schnorr}

\end{figure}


\begin{definition} A digital signature scheme $\DS$ is \emph{correct} if 
$$\Pr[sp\gets \DS.\Setup(1^\lambda); (sk,vk) \gets \DS.\Keygen(sp); m\gets \mathcal{M_{S}}:\DS.\Ver(vk,m,Sign(sk,m))=1 ] =1.$$
\end{definition}

\begin{definition} A digital signature scheme $\DS$ is \emph{strongly existentially unforgeable against chosen message attacks}  (sEUF-CMA)  if for all p.p.t.  adversaries \A, we have  
$$\Pr[\textsf{GsEUF-CMA}^{\A}_{\DS}(1^\lambda)] $$
is negligible in $\lambda$ where the game $\textsf{GsEUF-CMA}^{\A}_{\DS}$ is defined in Figure \ref{fig:seufcma}. \label{def:seufcma}
\end{definition}


\begin{figure}[ht]
\fbox{%
  \begin{minipage}{0.95\textwidth}
    % Top minipage
    
    \begin{minipage}[t]{0.05\textwidth}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.5\textwidth}

      \textbf{\uline{\bm{$\textsf{GsEUF-CMA}^{\A}_{\DS}(1^\lambda)$}}}\\[0.5ex]
$sp \gets \DS.\Setup(1^\lambda); Q\gets \emptyset$\\
$(sk,vk)\gets \DS.\Keygen(sp)\\ (m^*,\sigma^*)\gets \A^{\textsf{OSig}}(vk)$\\
$\textbf{return } (m^*,\sigma^*)\neq Q \land \DS.\Ver(vk,m^*,\sigma^*)$
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.35\textwidth}
      \textbf{\uline{\bm{$\textsf{OSig}(m)$}}}\\[0.5ex]
$\sigma \gets \DS.\Sign(skk,m)$\\
$Q \gets Q\cup \{(m,s)\}$\\
$\textbf{return } \sigma$
    \end{minipage}
    \hfill
    \begin{minipage}[t]{0.1\textwidth}
    \end{minipage}

  \end{minipage}%
}

\caption{The security game $\textsf{GsEUF-CMA}^{\A}_{\DS}$ and supporting oracle $\textsf{OSig}$.}\label{fig:seufcma}

\end{figure}


\begin{assumption} \label{ass:schnorr}\cite{blindsigs} There exists a group generator $\GGen$ and hash function generator $\HGen$ such that the Schnorr signature scheme $\SDS$ is strongly unforgeable under definition \ref{def:seufcma}. \end{assumption}

Similarly, in the ROM we can trivially guarantee $\hash$ is pseudorandom, whereas for our setting we require an additional assumption:

\begin{assumption} The hash function generator $\HGen$ is such that for all $n$\label{ass:hash}
$$\left| \Pr[\hash \gets \HGen(n); (m_0,m_1)\gets \A(\hash);b\gets\{0,1\};r\gets\{0,1\}^\lambda:b=\A(\hash(m_b||r))]-1/2 \right| $$ is negligible in $\lambda$. \end{assumption}

\subsection{Parametrized Non-Interactive Zero Knowledge Arguments}

Following \cite{blindsigs}, we define non-interactive zero knowledge arguments with regards to \emph parametrized polynomial relations $\mathcal{P}: \{0,1\}^* \times \{0,1\}^* \times \{0,1\}^*  \to \{0,1\}$, where the first argument represents a parameter set $par$ (e.g. a group description). Given a value of $par$, we say that $w$ is a witness for statement $\theta$ if $\mathcal{P}(par,\theta,w)=1$, i.e. $R=R_{par}(\theta,w):=\mathcal{P}(par,\theta,w)$ is an NP-relation, and $\Lang=\Lang_{par}$ is an NP-language. A NIZK for a relation  $\mathcal{P}$ operates as follows:
\begin{itemize}

\item $\mathsf{Rel}(1^\lambda) \to par$. Generates a parameter set $par$ that defines $R$ and $\Lang$.
\item $\Setup(par)\to (\crs,\tau)$. Generates a common reference string (CRS) and trapdoor $\tau$ used by the simulator. We assume the CRS contains a description of $R$.
\item $\Prove(\crs,\theta,w)\to \pi$. Given a CRS $\crs$, statement $\theta$ and witness $w$ for $\theta$, produces a proof $\pi$.  
\item $\Ver(\crs,\theta,\pi)\to \{0,1\}$. Given a CRS $\crs$, a statement $\theta$ and a  proof $\pi$ outputs 1 or 0, accepting or rejecting the proof.
\item $\SimProve(\crs,\theta,\tau)$. Given a CRS $\crs$, statement $\theta$ and traproor $\tau$ for $\crs$, produces a simulated proof $\pi$.
\end{itemize}


\begin{definition} A system $\NArgr$ is perfectly correct if for all unbounded adversaries $\A$ 
\begin{align*}
\Pr [par \gets \NArg.\mathsf{Rel}(1^\lambda);  (\crs,\tau)\gets \NArg.\Setup(par); (\theta,w) \gets A(crs):  \\
\neg{}R(\theta,w) \lor \NArg.\Ver(\crs,\theta,\NArg.\Prove(\crs,\theta,w))]=1 \\
\end{align*}
\end{definition}

\begin{definition} A system $\NArgr$ is adaptably computationally sound if for all p.p.t. adversaries $\A$ 
\begin{align*}
\Pr [par \gets \NArg.\mathsf{Rel}(1^\lambda);  (\crs,\tau)\gets \NArg.\Setup(par); (\theta,\pi) \gets A(crs):  \\
\neg{}L(\theta) \land {}\NArg.\Ver(\crs,\theta,\pi)] \mbox{ is negligible in $\lambda$.}
\end{align*}
\end{definition}

\begin{definition} A system $\NArgr$ is  computationally zero-knowledge if for all p.p.t. adversaries $\A$ 
\begin{align*}
|\Pr [par \gets \NArg.\mathsf{Rel}(1^\lambda);  (\crs,\tau)\gets \NArg.\Setup(par); d\gets\{0,1\}:  \\
d = A^{\mathsf{OProve}_d}(crs)] - {1\over2}|\mbox{ is negligible in $\lambda$, where}\\
\mathsf{OProve}_0(\theta,w):= \textbf{if } \neg R(\theta,w) \textbf{ return }\bot; \textbf{ return } \NArg.\Prove(\theta,w), \mbox{and} \\
\mathsf{OProve}_1(\theta,w):= \textbf{if } \neg R(\theta,w) \textbf{ return }\bot; \textbf{ return } \NArg.\SimProve(\theta,\tau).
  \end{align*}
\end{definition}
