name: Haskell build and test

on:
  push:
    branches: [ "master", "release/**" ]
    paths:
      - 'prototype/**'
      - '.github/workflows/cavefish-server-linux-ci.yml'

  pull_request:
    branches: [ "**" ]
    paths:
      - 'prototype/**'
      - '.github/workflows/cavefish-server-linux-ci.yml'

jobs:
  build:
    name: GHC ${{ matrix.ghc-version }} on ${{ matrix.os }} (lfs=${{ matrix.lfs }})
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest]
        ghc-version: ['9.6.6']
        lfs: [true]
      fail-fast: false

    env:
      # Modify this value to "invalidate" the cabal cache.
      CABAL_CACHE_VERSION: "2026-01-15"
      SECP256K1_REF: ac83be33d0956faf6b7f61a60ab524ef7d6a473a
      SECP_CACHE_VERSION: "2022-12-30"
      WBPS_TEST_INPUT_ROOT: ${{ github.workspace }}/prototype/packages/wbps/setup
      WBPS_TEST_OUTPUT_ROOT: ${{ github.workspace }}/prototype/output/tests
      CIRCOM_REV: "2eaaa6dface934356972b34cab64b25d382e59de"
      SNARKJS_VERSION: "0.7.6"

    defaults:
      run:
        shell: bash

    steps:
      - uses: actions/checkout@v4
        with:
          lfs: ${{ matrix.lfs }}
          fetch-depth: 0

      - name: Free up disk space
        run: |
          sudo rm -rf \
            "$AGENT_TOOLSDIRECTORY" \
            /opt/google/chrome \
            /opt/microsoft/msedge \
            /opt/microsoft/powershell \
            /opt/pipx \
            /usr/lib/mono \
            /usr/local/julia* \
            /usr/local/lib/android \
            /usr/local/lib/node_modules \
            /usr/local/share/chromium \
            /usr/local/share/powershell \
            /usr/share/dotnet \
            /usr/share/swift
          df -h /

      - name: Install system dependencies
        uses: input-output-hk/actions/base@latest
        with:
          use-sodium-vrf: false

      - name: Setup Node.js (for snarkjs)
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup Rust (for circom)
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo registry (circom build)
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            ~/.cache/sccache
          key: cargo-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            cargo-${{ runner.os }}-

      - name: Build babyjubjub-keygen (native) and add to PATH
        run: |
          DEST="$GITHUB_WORKSPACE/prototype/packages/wbps/inputs/babyjubjub-keygen"
          echo "Building babyjubjub-keygen for $(uname -m) -> $DEST"
          DEST="$DEST" bash "$GITHUB_WORKSPACE/zk-wbps/tooling/gen_babyjubjub_keys.sh"
          echo "$GITHUB_WORKSPACE/prototype/packages/wbps/inputs" >> "$GITHUB_PATH"

      - name: Install circom & snarkjs
        run: |
          cargo install --git https://github.com/iden3/circom --rev "$CIRCOM_REV" --locked --force
          npm install -g "snarkjs@$SNARKJS_VERSION"
          circom --version
          snarkjs -v || true

      - name: Circomlib
        working-directory: ./zk-wbps
        run: make deps-circomlib

      - name: Validate LFS setup artifacts
        if: ${{ matrix.lfs }}
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          SETUP="$ROOT/prototype/packages/wbps/setup"
          is_lfs_pointer() {
            local f="$1"
            [ -f "$f" ] && head -n 1 "$f" | grep -q "git-lfs.github.com/spec/v1"
          }

          for f in \
            "$SETUP/commitment/BuildCommitment.r1cs" \
            "$SETUP/commitment/BuildCommitment.sym" \
            "$SETUP/commitment/BuildCommitment_js/BuildCommitment.wasm" \
            "$SETUP/relation/relation.r1cs" \
            "$SETUP/relation/relation.sym" \
            "$SETUP/relation/relation_js/relation.wasm" \
            "$SETUP/powersOfTauPrepared.ptau"
          do
            if [ ! -f "$f" ]; then
              echo "Missing LFS artifact: $f"
              exit 1
            fi
            if is_lfs_pointer "$f"; then
              echo "LFS pointer detected (download failed?): $f"
              exit 1
            fi
          done

      - name: Generate WBPS setup artifacts (no LFS)
        if: ${{ !matrix.lfs }}
        run: |
          set -euo pipefail
          ROOT="$GITHUB_WORKSPACE"
          SETUP="$ROOT/prototype/packages/wbps/setup"
          mkdir -p "$SETUP/commitment" "$SETUP/relation"

          is_lfs_pointer() {
            local f="$1"
            [ -f "$f" ] && head -n 1 "$f" | grep -q "git-lfs.github.com/spec/v1"
          }

          need_build_commitment=0
          for f in \
            "$SETUP/commitment/BuildCommitment.r1cs" \
            "$SETUP/commitment/BuildCommitment.sym" \
            "$SETUP/commitment/BuildCommitment_js/BuildCommitment.wasm"
          do
            if [ ! -f "$f" ] || is_lfs_pointer "$f"; then
              need_build_commitment=1
              break
            fi
          done

          if [ "$need_build_commitment" -eq 1 ]; then
            echo "Compiling BuildCommitment.circom"
            rm -f "$SETUP/commitment/BuildCommitment.r1cs" "$SETUP/commitment/BuildCommitment.sym"
            rm -rf "$SETUP/commitment/BuildCommitment_js"
            circom "$SETUP/commitment/BuildCommitment.circom" \
              --r1cs --sym --wasm \
              -l "$ROOT/zk-wbps/vendor/circomlib" \
              -l "$ROOT/zk-wbps/vendor/hashing_circuits" \
              -o "$SETUP/commitment"
          fi

          need_relation=0
          for f in \
            "$SETUP/relation/relation.r1cs" \
            "$SETUP/relation/relation.sym" \
            "$SETUP/relation/relation_js/relation.wasm"
          do
            if [ ! -f "$f" ] || is_lfs_pointer "$f"; then
              need_relation=1
              break
            fi
          done

          if [ "$need_relation" -eq 1 ]; then
            echo "Compiling relation.circom"
            rm -f "$SETUP/relation/relation.r1cs" "$SETUP/relation/relation.sym"
            rm -rf "$SETUP/relation/relation_js"
            circom "$SETUP/relation/relation.circom" \
              --r1cs --sym --wasm \
              -l "$ROOT/zk-wbps/vendor/circomlib" \
              -l "$ROOT/zk-wbps/vendor/hashing_circuits" \
              -o "$SETUP/relation"
          fi

          if [ ! -f "$SETUP/powersOfTauPrepared.ptau" ] || is_lfs_pointer "$SETUP/powersOfTauPrepared.ptau"; then
            echo "Generating powersOfTauPrepared.ptau"
            rm -f "$SETUP/powersOfTauPrepared.ptau"
            constraints=$(snarkjs r1cs info "$SETUP/relation/relation.r1cs" 2>/dev/null | python3 -c 'import re,sys; data=sys.stdin.read(); m=re.search(r"Constraints\\s*[:=]\\s*([0-9,]+)", data); print("" if not m else m.group(1).replace(",",""))' || true)
            if [ -z "${constraints:-}" ]; then
              constraints=2000000
            fi
            bits=$(python3 -c 'import math; constraints=int("'"${constraints}"'"); bits=math.ceil(math.log2(constraints)) + 1; print(max(bits, 22))')
            echo "Using PTAU_BITS=$bits for constraints=$constraints"
            tmp_ptau="$RUNNER_TEMP/powersoftau.ptau"
            snarkjs powersoftau new bn128 "$bits" "$tmp_ptau" -v
            snarkjs powersoftau prepare phase2 "$tmp_ptau" "$SETUP/powersOfTauPrepared.ptau" -v
          fi

      - name: Install Haskell
        id: install-haskell
        uses: input-output-hk/actions/haskell@latest
        with:
          ghc-version: ${{ matrix.ghc-version }}
          cabal-version: 3.12.1.0

      - name: Configure to use libsodium
        run: |
          cat >> cabal.project <<EOF
          package cardano-crypto-praos
            flags: -external-libsodium-vrf
          EOF

      - name: Cabal update
        working-directory: ./prototype
        run: cabal update

        # We create a dependencies.txt file that can be used to index the cabal
        # store cache.
        #
        # We do not use plan.json directly because adding a dependency to our
        # Cabal files which was already present somewhere else would result in a
        # diferent plan, even though the set of dependencies is the same.
      - name: Record dependencies to be used as cache keys
        working-directory: ./prototype
        id: record-deps
        run: |
          cabal build all --enable-tests --dry-run --minimize-conflict-set
          cat dist-newstyle/cache/plan.json \
          | jq '.["install-plan"][].id' \
          | sort \
          | uniq \
          | tee dependencies.txt

      - name: Restore cache
        uses: actions/cache/restore@v4
        id: restore-cabal-cache
        env:
          cache-name: cache-cabal-build
        with:
          path: |
            ${{ steps.install-haskell.outputs.cabal-store }}
          # A new cache is created upon a change to the cabal build plan,
          # cabal.project (and/or cabal.project.local), or a bump to
          # CABAL_CACHE_VERSION.
          key: ${{ env.cache-name }}-${{ runner.os }}-${{ matrix.ghc-version }}-${{ env.CABAL_CACHE_VERSION }}-${{ hashFiles('dependencies.txt') }}-${{ hashFiles('cabal.project*') }}
          # Restoring attempts are from current branch then master. The key above
          # is by default already a restore-key.
          restore-keys: |
            ${{ env.cache-name }}-${{ runner.os }}-${{ matrix.ghc-version }}-${{ env.CABAL_CACHE_VERSION }}-${{ hashFiles('dependencies.txt') }}
            ${{ env.cache-name }}-${{ runner.os }}-${{ matrix.ghc-version }}-${{ env.CABAL_CACHE_VERSION }}-

      - name: Install build tools and helpers
        run: |
          cabal install doctest --flag cabal-doctest --ignore-project --overwrite-policy=always
          cabal path --installdir >> "$GITHUB_PATH"

      - name: Check workflow test matrix
        working-directory: ./prototype
        run: cabal build all --dry-run

      - name: Build dependencies
        working-directory: ./prototype
        id: build-dependencies
        run: cabal build all --only-dependencies

      - name: Save cache
        uses: actions/cache/save@v4
        id: save-cabal-cache
        # Note: cache-hit will be set to true only when cache hit occurs for the
        # exact key match. For a partial key match via restore-keys or a cache
        # miss, it will be set to false.
        if: steps.build-dependencies.outcome == 'success' && steps.restore-cabal-cache.outputs.cache-hit != 'true'
        with:
          path: ${{ steps.install-haskell.outputs.cabal-store }}
          key:  ${{ steps.restore-cabal-cache.outputs.cache-primary-key }}

      - name: Build
        working-directory: ./prototype
        run: cabal build all

      - name: Test
        working-directory: ./prototype
        run: cabal test all
